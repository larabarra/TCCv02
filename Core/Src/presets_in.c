/**
  ******************************************************************************
  * @file           : presets_in.c
  * @brief          : Preset Input Sensor Functions
  * @date           : Oct 30, 2025
  * @author         : Auto-generated by Config Tool
  ******************************************************************************
  */

#include "presets_in.h"

/* =========================
 *  GY-521 (MPU6050) - MPU6050 Register definitions
 * ========================= */
#define MPU6050_REG_SMPLRT_DIV      0x19
#define MPU6050_REG_PWR_MGMT_1     0x6B
#define MPU6050_REG_ACCEL_CFG       0x1C
#define MPU6050_REG_GYRO_CFG        0x1B
#define MPU6050_REG_ACCEL_XOUT      0x3B
#define MPU6050_REG_GYRO_XOUT       0x43
#define MPU6050_REG_WHO_AM_I        0x75
#define MPU6050_WHOAMI_VALUE        0x68

/* =========================
 *  GY-521 (MPU6050) Implementation
 * ========================= */

#define _MPU6050_HI2C   hi2c1
#define _MPU6050_ADDR   (0x68 << 1)  // 8-bit address for HAL

HAL_StatusTypeDef MPU6050_Init_I2C1(void)
{
    uint8_t check = 0;
    uint8_t data  = 0;

    if (HAL_I2C_Mem_Read(&_MPU6050_HI2C, _MPU6050_ADDR, MPU6050_REG_WHO_AM_I, 1, &check, 1, 1000) != HAL_OK)
        return HAL_ERROR;
    if (check != MPU6050_WHOAMI_VALUE)
        return HAL_ERROR;

    data = 0x00;  // wake up
    if (HAL_I2C_Mem_Write(&_MPU6050_HI2C, _MPU6050_ADDR, MPU6050_REG_PWR_MGMT_1, 1, &data, 1, 1000) != HAL_OK)
        return HAL_ERROR;

    data = 0x07;  // sample rate
    if (HAL_I2C_Mem_Write(&_MPU6050_HI2C, _MPU6050_ADDR, MPU6050_REG_SMPLRT_DIV, 1, &data, 1, 1000) != HAL_OK)
        return HAL_ERROR;

    data = 0x00;  // accel ±2g
    if (HAL_I2C_Mem_Write(&_MPU6050_HI2C, _MPU6050_ADDR, MPU6050_REG_ACCEL_CFG, 1, &data, 1, 1000) != HAL_OK)
        return HAL_ERROR;

    data = 0x00;  // gyro ±250 dps
    if (HAL_I2C_Mem_Write(&_MPU6050_HI2C, _MPU6050_ADDR, MPU6050_REG_GYRO_CFG, 1, &data, 1, 1000) != HAL_OK)
        return HAL_ERROR;

    return HAL_OK;
}

HAL_StatusTypeDef MPU6050_Read_Accel_I2C1(int16_t* ax, int16_t* ay, int16_t* az, float* Ax_g, float* Ay_g, float* Az_g)
{
    uint8_t r[6];
    if (HAL_I2C_Mem_Read(&_MPU6050_HI2C, _MPU6050_ADDR, MPU6050_REG_ACCEL_XOUT, 1, r, 6, 1000) != HAL_OK)
        return HAL_ERROR;

    int16_t ax_raw = (int16_t)((r[0] << 8) | r[1]);
    int16_t ay_raw = (int16_t)((r[2] << 8) | r[3]);
    int16_t az_raw = (int16_t)((r[4] << 8) | r[5]);

    if (ax) *ax = ax_raw;
    if (ay) *ay = ay_raw;
    if (az) *az = az_raw;
    if (Ax_g) *Ax_g = (float)ax_raw / 16384.0f;
    if (Ay_g) *Ay_g = (float)ay_raw / 16384.0f;
    if (Az_g) *Az_g = (float)az_raw / 16384.0f;

    return HAL_OK;
}

HAL_StatusTypeDef MPU6050_Read_Gyro_I2C1(int16_t* gx, int16_t* gy, int16_t* gz, float* Gx_dps, float* Gy_dps, float* Gz_dps)
{
    uint8_t r[6];
    if (HAL_I2C_Mem_Read(&_MPU6050_HI2C, _MPU6050_ADDR, MPU6050_REG_GYRO_XOUT, 1, r, 6, 1000) != HAL_OK)
        return HAL_ERROR;

    int16_t gx_raw = (int16_t)((r[0] << 8) | r[1]);
    int16_t gy_raw = (int16_t)((r[2] << 8) | r[3]);
    int16_t gz_raw = (int16_t)((r[4] << 8) | r[5]);

    if (gx) *gx = gx_raw;
    if (gy) *gy = gy_raw;
    if (gz) *gz = gz_raw;
    if (Gx_dps) *Gx_dps = (float)gx_raw / 131.0f;
    if (Gy_dps) *Gy_dps = (float)gy_raw / 131.0f;
    if (Gz_dps) *Gz_dps = (float)gz_raw / 131.0f;

    return HAL_OK;
}

#undef _MPU6050_HI2C
#undef _MPU6050_ADDR


// Simplified wrapper functions for the template
void MPU6050_Init(void)
{
    MPU6050_Init_I2C1();
}

void MPU6050_Read_Accel(float *ax, float *ay, float *az)
{
    int16_t ax_raw, ay_raw, az_raw;
    float ax_g, ay_g, az_g;
    
    if (MPU6050_Read_Accel_I2C1(&ax_raw, &ay_raw, &az_raw, &ax_g, &ay_g, &az_g) == HAL_OK)
    {
        if (ax) *ax = ax_g;
        if (ay) *ay = ay_g;
        if (az) *az = az_g;
    }
}

void MPU6050_Read_Gyro(float *gx, float *gy, float *gz)
{
    int16_t gx_raw, gy_raw, gz_raw;
    float gx_dps, gy_dps, gz_dps;
    
    if (MPU6050_Read_Gyro_I2C1(&gx_raw, &gy_raw, &gz_raw, &gx_dps, &gy_dps, &gz_dps) == HAL_OK)
    {
        if (gx) *gx = gx_dps;
        if (gy) *gy = gy_dps;
        if (gz) *gz = gz_dps;
    }
}




