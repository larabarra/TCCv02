/**
  ******************************************************************************
  * @file           : presets_in.c
  * @brief          : Preset Input Sensor Functions
  * @date           : {{ now().strftime('%b %d, %Y') }}
  * @author         : Auto-generated by Config Tool
  ******************************************************************************
  */

#include "presets_in.h"

{% if include_gy521 and gy521_devices %}
/* =========================
 *  GY-521 (MPU6050) - MPU6050 Register definitions
 * ========================= */
#define MPU6050_REG_SMPLRT_DIV      0x19
#define MPU6050_REG_PWR_MGMT_1     0x6B
#define MPU6050_REG_ACCEL_CFG       0x1C
#define MPU6050_REG_GYRO_CFG        0x1B
#define MPU6050_REG_ACCEL_XOUT      0x3B
#define MPU6050_REG_GYRO_XOUT       0x43
#define MPU6050_REG_WHO_AM_I        0x75
#define MPU6050_WHOAMI_VALUE        0x68

/* =========================
 *  GY-521 (MPU6050) Implementation
 * ========================= */

{% for d in gy521_devices %}
#define _MPU6050_HI2C   {{ d.handle }}
#define _MPU6050_ADDR   ({{ d.addr_macro }} << 1)  // 8-bit address for HAL

HAL_StatusTypeDef MPU6050_Init_I2C{{ d.num }}(void)
{
    uint8_t check = 0;
    uint8_t data  = 0;

    if (HAL_I2C_Mem_Read(&_MPU6050_HI2C, _MPU6050_ADDR, MPU6050_REG_WHO_AM_I, 1, &check, 1, 1000) != HAL_OK)
        return HAL_ERROR;
    if (check != MPU6050_WHOAMI_VALUE)
        return HAL_ERROR;

    data = 0x00;  // wake up
    if (HAL_I2C_Mem_Write(&_MPU6050_HI2C, _MPU6050_ADDR, MPU6050_REG_PWR_MGMT_1, 1, &data, 1, 1000) != HAL_OK)
        return HAL_ERROR;

    data = 0x07;  // sample rate
    if (HAL_I2C_Mem_Write(&_MPU6050_HI2C, _MPU6050_ADDR, MPU6050_REG_SMPLRT_DIV, 1, &data, 1, 1000) != HAL_OK)
        return HAL_ERROR;

    data = 0x00;  // accel ±2g
    if (HAL_I2C_Mem_Write(&_MPU6050_HI2C, _MPU6050_ADDR, MPU6050_REG_ACCEL_CFG, 1, &data, 1, 1000) != HAL_OK)
        return HAL_ERROR;

    data = 0x00;  // gyro ±250 dps
    if (HAL_I2C_Mem_Write(&_MPU6050_HI2C, _MPU6050_ADDR, MPU6050_REG_GYRO_CFG, 1, &data, 1, 1000) != HAL_OK)
        return HAL_ERROR;

    return HAL_OK;
}

HAL_StatusTypeDef MPU6050_Read_Accel_I2C{{ d.num }}(int16_t* ax, int16_t* ay, int16_t* az, float* Ax_g, float* Ay_g, float* Az_g)
{
    uint8_t r[6];
    if (HAL_I2C_Mem_Read(&_MPU6050_HI2C, _MPU6050_ADDR, MPU6050_REG_ACCEL_XOUT, 1, r, 6, 1000) != HAL_OK)
        return HAL_ERROR;

    int16_t ax_raw = (int16_t)((r[0] << 8) | r[1]);
    int16_t ay_raw = (int16_t)((r[2] << 8) | r[3]);
    int16_t az_raw = (int16_t)((r[4] << 8) | r[5]);

    if (ax) *ax = ax_raw;
    if (ay) *ay = ay_raw;
    if (az) *az = az_raw;
    if (Ax_g) *Ax_g = (float)ax_raw / 16384.0f;
    if (Ay_g) *Ay_g = (float)ay_raw / 16384.0f;
    if (Az_g) *Az_g = (float)az_raw / 16384.0f;

    return HAL_OK;
}

HAL_StatusTypeDef MPU6050_Read_Gyro_I2C{{ d.num }}(int16_t* gx, int16_t* gy, int16_t* gz, float* Gx_dps, float* Gy_dps, float* Gz_dps)
{
    uint8_t r[6];
    if (HAL_I2C_Mem_Read(&_MPU6050_HI2C, _MPU6050_ADDR, MPU6050_REG_GYRO_XOUT, 1, r, 6, 1000) != HAL_OK)
        return HAL_ERROR;

    int16_t gx_raw = (int16_t)((r[0] << 8) | r[1]);
    int16_t gy_raw = (int16_t)((r[2] << 8) | r[3]);
    int16_t gz_raw = (int16_t)((r[4] << 8) | r[5]);

    if (gx) *gx = gx_raw;
    if (gy) *gy = gy_raw;
    if (gz) *gz = gz_raw;
    if (Gx_dps) *Gx_dps = (float)gx_raw / 131.0f;
    if (Gy_dps) *Gy_dps = (float)gy_raw / 131.0f;
    if (Gz_dps) *Gz_dps = (float)gz_raw / 131.0f;

    return HAL_OK;
}

#undef _MPU6050_HI2C
#undef _MPU6050_ADDR

{% endfor %}
{% endif %}

{% if gy521_devices %}
// Simplified wrapper functions for the template
void MPU6050_Init(void)
{
    {% for d in gy521_devices %}
    MPU6050_Init_I2C{{ d.num }}();
    {% endfor %}
}

void MPU6050_Read_Accel(float *ax, float *ay, float *az)
{
    int16_t ax_raw, ay_raw, az_raw;
    float ax_g, ay_g, az_g;
    
    {% for d in gy521_devices %}
    if (MPU6050_Read_Accel_I2C{{ d.num }}(&ax_raw, &ay_raw, &az_raw, &ax_g, &ay_g, &az_g) == HAL_OK)
    {
        if (ax) *ax = ax_g;
        if (ay) *ay = ay_g;
        if (az) *az = az_g;
    }
    {% endfor %}
}

void MPU6050_Read_Gyro(float *gx, float *gy, float *gz)
{
    int16_t gx_raw, gy_raw, gz_raw;
    float gx_dps, gy_dps, gz_dps;
    
    {% for d in gy521_devices %}
    if (MPU6050_Read_Gyro_I2C{{ d.num }}(&gx_raw, &gy_raw, &gz_raw, &gx_dps, &gy_dps, &gz_dps) == HAL_OK)
    {
        if (gx) *gx = gx_dps;
        if (gy) *gy = gy_dps;
        if (gz) *gz = gz_dps;
    }
    {% endfor %}
}
{% endif %}

{% if include_din and din_pin %}
/* =========================
 *  Digital Input generic
 * ========================= */
GPIO_PinState DI_Read_{{ din_pin.name }}(void)
{
    return HAL_GPIO_ReadPin({{ din_pin.port }}, GPIO_PIN_{{ din_pin.pin }});
}
{% endif %}

{% if include_dht11 %}
/* =========================
 *  DHT11 Implementation
 * ========================= */

{% if dht_pin %}
// Microsecond delay using DWT (Data Watchpoint and Trace) cycle counter
// Must be defined BEFORE DHT11_Read to avoid implicit declaration warning
static inline void DWT_Delay_us(uint32_t us)
{
    uint32_t startTick = DWT->CYCCNT;
    uint32_t delayTicks = us * (SystemCoreClock / 1000000);
    while((DWT->CYCCNT - startTick) < delayTicks);
}

// DHT11 Read function - Returns temperature and humidity
DHT11_Data_t DHT11_Read(void)
{
    DHT11_Data_t dht_data = {0};
    uint8_t data[5] = {0};
    uint32_t timeout;
    
    // Set pin as output and send start signal
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = GPIO_PIN_{{ dht_pin.pin }};
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init({{ dht_pin.port }}, &GPIO_InitStruct);
    
    // Send start signal: LOW for 18ms
    HAL_GPIO_WritePin({{ dht_pin.port }}, GPIO_PIN_{{ dht_pin.pin }}, GPIO_PIN_RESET);
    HAL_Delay(18);
    HAL_GPIO_WritePin({{ dht_pin.port }}, GPIO_PIN_{{ dht_pin.pin }}, GPIO_PIN_SET);
    DWT_Delay_us(20);  // Wait 20us
    
    // Set pin as input
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    HAL_GPIO_Init({{ dht_pin.port }}, &GPIO_InitStruct);
    
    // Wait for DHT11 response (80us LOW + 80us HIGH)
    timeout = 1000;
    while(HAL_GPIO_ReadPin({{ dht_pin.port }}, GPIO_PIN_{{ dht_pin.pin }}) == GPIO_PIN_SET && timeout--);
    if(timeout == 0) { dht_data.status = HAL_ERROR; return dht_data; }
    
    timeout = 1000;
    while(HAL_GPIO_ReadPin({{ dht_pin.port }}, GPIO_PIN_{{ dht_pin.pin }}) == GPIO_PIN_RESET && timeout--);
    if(timeout == 0) { dht_data.status = HAL_ERROR; return dht_data; }
    
    timeout = 1000;
    while(HAL_GPIO_ReadPin({{ dht_pin.port }}, GPIO_PIN_{{ dht_pin.pin }}) == GPIO_PIN_SET && timeout--);
    if(timeout == 0) { dht_data.status = HAL_ERROR; return dht_data; }
    
    // Read 40 bits (5 bytes)
    for(int i = 0; i < 5; i++) {
        for(int j = 7; j >= 0; j--) {
            // Wait for bit start (50us LOW)
            timeout = 1000;
            while(HAL_GPIO_ReadPin({{ dht_pin.port }}, GPIO_PIN_{{ dht_pin.pin }}) == GPIO_PIN_RESET && timeout--);
            if(timeout == 0) { dht_data.status = HAL_ERROR; return dht_data; }
            
            // Wait 40us and check if still HIGH
            DWT_Delay_us(40);
            if(HAL_GPIO_ReadPin({{ dht_pin.port }}, GPIO_PIN_{{ dht_pin.pin }}) == GPIO_PIN_SET) {
                data[i] |= (1 << j);  // Bit is 1
            }
            
            // Wait for bit end
            timeout = 1000;
            while(HAL_GPIO_ReadPin({{ dht_pin.port }}, GPIO_PIN_{{ dht_pin.pin }}) == GPIO_PIN_SET && timeout--);
            if(timeout == 0) { dht_data.status = HAL_ERROR; return dht_data; }
        }
    }
    
    // Verify checksum
    if(data[4] != ((data[0] + data[1] + data[2] + data[3]) & 0xFF)) {
        dht_data.status = HAL_ERROR;
        return dht_data;
    }
    
    // Parse data
    dht_data.hum_int = data[0];
    dht_data.hum_dec = data[1];
    dht_data.temp_int = data[2];
    dht_data.temp_dec = data[3];
    dht_data.status = HAL_OK;
    
    return dht_data;
}
{% endif %}
{% endif %}

{% if include_ky013 or include_pot %}
/* =========================
 *  KY-013 (ADC) and Potentiometer (ADC)
 * ========================= */
{% if include_ky013 %}
HAL_StatusTypeDef KY013_ReadRaw(ADC_HandleTypeDef* hadc, uint32_t channel, uint16_t* out_raw)
{
    if (!hadc || !out_raw) return HAL_ERROR;
    HAL_ADC_ConfigChannel(hadc, &(ADC_ChannelConfTypeDef){ .Channel=channel, .Rank=ADC_REGULAR_RANK_1, .SamplingTime=ADC_SAMPLETIME_47CYCLES_5 });
    if (HAL_ADC_Start(hadc) != HAL_OK) return HAL_ERROR;
    if (HAL_ADC_PollForConversion(hadc, 10) != HAL_OK) return HAL_ERROR;
    *out_raw = (uint16_t)HAL_ADC_GetValue(hadc);
    HAL_ADC_Stop(hadc);
    return HAL_OK;
}
float KY013_RawToVoltage(uint16_t raw, float vref)
{
    return ( (float)raw / 4095.0f ) * vref;
}
{% endif %}
{% endif %}

{% if include_pot %}
HAL_StatusTypeDef POT_ReadRaw(ADC_HandleTypeDef* hadc, uint32_t channel, uint16_t* out_raw)
{
    if (!hadc || !out_raw) return HAL_ERROR;
    HAL_ADC_ConfigChannel(hadc, &(ADC_ChannelConfTypeDef){ .Channel=channel, .Rank=ADC_REGULAR_RANK_1, .SamplingTime=ADC_SAMPLETIME_47CYCLES_5 });
    if (HAL_ADC_Start(hadc) != HAL_OK) return HAL_ERROR;
    if (HAL_ADC_PollForConversion(hadc, 10) != HAL_OK) return HAL_ERROR;
    *out_raw = (uint16_t)HAL_ADC_GetValue(hadc);
    HAL_ADC_Stop(hadc);
    return HAL_OK;
}
float POT_RawToRatio(uint16_t raw)
{
    return (float)raw / 4095.0f;
}
{% endif %}
